<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Posts</title>
  <!-- Tus estilos del widget (no añadimos CSS nuevo) -->
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

  <!-- Header -->
  <header class="toolbar">
    <div class="toolbar-left">
      <h1 class="title">Posts <span id="count" class="count"></span></h1>
    </div>
    <div class="toolbar-right">
      <button id="btnRefresh" class="btn">Refresh</button>
    </div>
  </header>

  <!-- Filtros -->
  <section class="filters">
    <div class="filters-row">
      <select id="selProject" aria-label="Project">
        <option value="">All Projects</option>
      </select>

      <select id="selClient" aria-label="Client">
        <option value="">All Clients</option>
      </select>

      <select id="selBrand" aria-label="Brand" disabled>
        <option value="">All Brands</option>
      </select>

      <label class="toggle">
        <input type="checkbox" id="chkDraft" />
        <span>Draft only</span>
      </label>
    </div>

    <div class="filters-row">
      <input id="txtSearch" type="search" placeholder="Buscar posts..." />
    </div>

    <div id="chips" class="chips"></div>
  </section>

  <!-- Grid -->
  <main>
    <div id="grid" class="grid"></div>
    <div class="loadmore-wrap">
      <button id="btnMore" class="btn" style="display:none;">Load more</button>
    </div>
  </main>

  <!-- Modal -->
  <div id="modal" class="modal" hidden>
    <div class="modal-content">
      <button id="modalClose" class="btn btn-ghost" aria-label="Close">×</button>
      <div class="modal-header">
        <h2 id="modalTitle"></h2>
      </div>
      <div class="modal-body">
        <img id="modalImg" alt="" />
        <video id="modalVid" controls playsinline hidden></video>
      </div>
    </div>
  </div>

  <script>
  // ==================== Estado ====================
  const STATE = {
    meta: { projects: [], clients: [], brandsByClient: {} },
    filters: { project: '', client: '', brand: '', q: '', draft: false },
    page: 1, pageSize: 24, hasMore: false,
    view: [] // posts acumulados para "Load more"
  };

  // ==================== DOM ====================
  const el = {
    selProject: document.getElementById('selProject'),
    selClient:  document.getElementById('selClient'),
    selBrand:   document.getElementById('selBrand'),
    chkDraft:   document.getElementById('chkDraft'),
    txtSearch:  document.getElementById('txtSearch'),
    chips:      document.getElementById('chips'),
    grid:       document.getElementById('grid'),
    count:      document.getElementById('count'),
    btnMore:    document.getElementById('btnMore'),
    btnRefresh: document.getElementById('btnRefresh'),
    modal:      document.getElementById('modal'),
    modalClose: document.getElementById('modalClose'),
    modalTitle: document.getElementById('modalTitle'),
    modalImg:   document.getElementById('modalImg'),
    modalVid:   document.getElementById('modalVid'),
  };

  // ==================== Utils ====================
  const esc = s => String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));
  const debounce = (fn, ms=250) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };

  // ==================== META (projects/clients/brands) ====================
  async function loadMeta() {
    const r = await fetch('/api/grid?meta=1');
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || 'Error meta');
    STATE.meta = j.filters || { projects:[], clients:[], brandsByClient:{} };
    paintSelects();
  }

  function paintSelects() {
    // Projects
    el.selProject.innerHTML = '<option value="">All Projects</option>' +
      (STATE.meta.projects || []).map(p => `<option>${esc(p)}</option>`).join('');
    if (STATE.filters.project) el.selProject.value = STATE.filters.project;

    // Clients
    el.selClient.innerHTML = '<option value="">All Clients</option>' +
      (STATE.meta.clients || []).map(c => `<option>${esc(c)}</option>`).join('');
    if (STATE.filters.client) el.selClient.value = STATE.filters.client;

    // Brands (depende del client)
    paintBrands();
  }

  function paintBrands() {
    const c = STATE.filters.client;
    const pool = c ? (STATE.meta.brandsByClient[c] || []) : [];
    el.selBrand.disabled = !c;
    el.selBrand.innerHTML = '<option value="">All Brands</option>' + pool.map(b=>`<option>${esc(b)}</option>`).join('');
    // autoselect si hay una sola
    if (c && pool.length === 1) {
      STATE.filters.brand = pool[0];
      el.selBrand.value = pool[0];
    } else if (!pool.includes(STATE.filters.brand)) {
      STATE.filters.brand = '';
    }
    paintChips();
  }

  // ==================== FETCH POSTS (server-side filters/paginación) ====================
  function buildQS() {
    const p = new URLSearchParams();
    if (STATE.filters.project) p.set('project', STATE.filters.project);
    if (STATE.filters.client)  p.set('client',  STATE.filters.client);
    if (STATE.filters.brand)   p.set('brand',   STATE.filters.brand);
    if (STATE.filters.q)       p.set('q',       STATE.filters.q);
    if (STATE.filters.draft)   p.set('draft',   '1');
    p.set('page', STATE.page);
    p.set('pageSize', STATE.pageSize);
    return p.toString();
  }

  async function loadPosts(reset=true) {
    if (reset) { STATE.page = 1; STATE.view = []; STATE.hasMore = false; }
    const r = await fetch('/api/grid?' + buildQS());
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || 'Error /api/grid');

    const posts = j.posts || [];
    STATE.hasMore = !!j.hasMore;
    STATE.view = reset ? posts : STATE.view.concat(posts);

    renderGrid();
    paintChips();
    el.btnMore.style.display = STATE.hasMore ? '' : 'none';
  }

  // ==================== RENDER ====================
  function renderGrid() {
    el.grid.innerHTML = '';
    el.count.textContent = STATE.view.length ? `(${STATE.view.length})` : '';

    if (!STATE.view.length) {
      el.grid.innerHTML = '<div class="empty">No results</div>';
      return;
    }

    STATE.view.forEach(post => el.grid.appendChild(renderCard(post)));
    wireAutoplayHover();
  }

  function renderCard(post) {
    const card = document.createElement('button');
    card.className = 'card';
    card.type = 'button';
    card.setAttribute('aria-label', post.title || 'post');

    const a0 = (post.assets && post.assets[0]) || null;

    if (a0 && a0.type === 'video') {
      card.innerHTML = `
        <div class="media-wrap">
          <video class="media" src="${encodeURI(a0.url)}" muted playsinline></video>
          <span class="badge badge-video">▶</span>
        </div>
        <div class="overlay">
          <div class="ovl-title">${esc(post.title || '')}</div>
          <div class="ovl-meta">
            ${esc(post.client || '')}${post.project ? ' · ' + esc(post.project) : ''}${post.date ? ' · ' + esc(post.date) : ''}
          </div>
        </div>
      `;
    } else if (a0 && a0.type === 'image') {
      card.innerHTML = `
        <div class="media-wrap">
          <img class="media" src="${encodeURI(a0.url)}" alt="${esc(post.title || '')}" />
        </div>
        <div class="overlay">
          <div class="ovl-title">${esc(post.title || '')}</div>
          <div class="ovl-meta">
            ${esc(post.client || '')}${post.project ? ' · ' + esc(post.project) : ''}${post.date ? ' · ' + esc(post.date) : ''}
          </div>
        </div>
      `;
    } else {
      card.innerHTML = `<div class="media-wrap placeholder">No image</div>`;
    }

    // badge carrusel si hay múltiples assets
    if (post.assets && post.assets.length > 1) {
      const b = document.createElement('span');
      b.className = 'badge badge-carousel';
      b.textContent = 'IG';
      card.querySelector('.media-wrap')?.appendChild(b);
    }

    // abrir modal
    card.addEventListener('click', () => openModal(post, 0));
    return card;
  }

  function wireAutoplayHover() {
    document.querySelectorAll('.card video').forEach(v => {
      const host = v.closest('.card') || v;
      host.addEventListener('mouseenter', () => v.play().catch(()=>{}));
      host.addEventListener('mouseleave', () => v.pause());
    });
  }

  // ==================== Modal (con soporte de múltiples assets) ====================
  let MOD = { post: null, i: 0 };

  function openModal(post, idx=0) {
    MOD.post = post; MOD.i = Math.max(0, Math.min(idx, (post.assets||[]).length-1));
    const a = (post.assets || [])[MOD.i];

    el.modalTitle.textContent = post.title || '';
    if (a && a.type === 'video') {
      el.modalVid.src = a.url;
      el.modalVid.hidden = false;
      el.modalImg.hidden = true;
      // sonido solo en modal (no muted)
      el.modalVid.muted = false;
      el.modalVid.play().catch(()=>{});
    } else {
      el.modalImg.src = a ? a.url : '';
      el.modalImg.hidden = false;
      el.modalVid.hidden = true;
      el.modalVid.pause(); el.modalVid.currentTime = 0;
    }
    el.modal.hidden = false;
  }
  function closeModal() {
    el.modal.hidden = true;
    el.modalVid.pause(); el.modalVid.currentTime = 0;
    MOD = { post:null, i:0 };
  }
  function nextAsset() {
    if (!MOD.post) return;
    const total = (MOD.post.assets || []).length;
    if (total <= 1) return;
    MOD.i = (MOD.i + 1) % total;
    openModal(MOD.post, MOD.i);
  }
  function prevAsset() {
    if (!MOD.post) return;
    const total = (MOD.post.assets || []).length;
    if (total <= 1) return;
    MOD.i = (MOD.i - 1 + total) % total;
    openModal(MOD.post, MOD.i);
  }

  el.modalClose.addEventListener('click', closeModal);
  el.modal.addEventListener('click', (e) => { if (e.target === el.modal) closeModal(); });
  document.addEventListener('keydown', (e) => {
    if (el.modal.hidden) return;
    if (e.key === 'Escape') closeModal();
    if (e.key === 'ArrowRight') nextAsset();
    if (e.key === 'ArrowLeft')  prevAsset();
  });

  // ==================== Chips ====================
  function paintChips() {
    const f = STATE.filters;
    const parts = [];
    if (f.project) parts.push(chip('Project', f.project, () => { f.project=''; el.selProject.value=''; reload(); }));
    if (f.client)  parts.push(chip('Client',  f.client,  () => { f.client=''; el.selClient.value=''; f.brand=''; paintBrands(); reload(); }));
    if (f.brand)   parts.push(chip('Brand',   f.brand,   () => { f.brand=''; el.selBrand.value=''; reload(); }));
    if (f.q)       parts.push(chip('q',       f.q,       () => { f.q=''; el.txtSearch.value=''; reload(); }));
    if (f.draft)   parts.push(chip('Draft',   'on',      () => { f.draft=false; el.chkDraft.checked=false; reload(); }));

    el.chips.innerHTML = parts.join('') + (parts.length ? `<button type="button" class="chip-clear" id="chipClear">Clear all</button>` : '');
    document.getElementById('chipClear')?.addEventListener('click', () => {
      STATE.filters = { project:'', client:'', brand:'', q:'', draft:false };
      el.selProject.value=''; el.selClient.value=''; el.selBrand.value='';
      el.txtSearch.value=''; el.chkDraft.checked=false;
      paintBrands();
      reload();
    });
  }
  function chip(label, value, onX) {
    const id = 'x-' + Math.random().toString(36).slice(2);
    queueMicrotask(()=> document.getElementById(id)?.addEventListener('click', onX));
    return `<span class="chip">${esc(label)}: ${esc(value)} <button type="button" id="${id}" aria-label="Remove">×</button></span>`;
  }

  // ==================== Eventos UI ====================
  function bindUI() {
    el.btnRefresh.addEventListener('click', () => reload());
    el.selProject.addEventListener('change', () => { STATE.filters.project = el.selProject.value || ''; reload(); });
    el.selClient .addEventListener('change', () => { STATE.filters.client  = el.selClient.value  || ''; paintBrands(); reload(); });
    el.selBrand  .addEventListener('change', () => { STATE.filters.brand   = el.selBrand.value   || ''; reload(); });
    el.chkDraft  .addEventListener('change', () => { STATE.filters.draft   = !!el.chkDraft.checked; reload(); });
    el.txtSearch .addEventListener('input', debounce(() => { STATE.filters.q = el.txtSearch.value.trim(); reload(); }, 250));
    el.btnMore   .addEventListener('click', () => { STATE.page += 1; loadPosts(false); });
  }

  async function reload() {
    paintChips();
    await loadPosts(true);
  }

  // ==================== Init ====================
  (async function init() {
    bindUI();
    await loadMeta();
    await loadPosts(true);
  })().catch(err => {
    el.grid.innerHTML = `<div class="error">Error: ${esc(err.message)}</div>`;
  });
  </script>
</body>
</html>
